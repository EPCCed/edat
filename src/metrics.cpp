/*
* Copyright (c) 2018, EPCC, The University of Edinburgh
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
* 1. Redistributions of source code must retain the above copyright notice, this
*   list of conditions and the following disclaimer.
*
* 2. Redistributions in binary form must reproduce the above copyright notice,
*    this list of conditions and the following disclaimer in the documentation
*    and/or other materials provided with the distribution.
*
* 3. Neither the name of the copyright holder nor the names of its
*    contributors may be used to endorse or promote products derived from
*    this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "metrics.h"
#include <iostream>
#include <iomanip>
#include <sstream>
#include <mutex>
#include <map>
#include <string>
#include <chrono>
#include <cmath>
#include <thread>

namespace metrics {
  EDAT_Metrics * METRICS;
}

EDAT_Metrics::EDAT_Metrics(Configuration & aconfig) : configuration(aconfig) {
  num_threads = configuration.get("EDAT_NUM_WORKERS", std::thread::hardware_concurrency());
  thread_active.resize(num_threads, ns::zero());
  thread_active_pc.resize(num_threads, 0.0);
}

void EDAT_Metrics::edatTimerStart(void) {
  edat_timer_key = timerStart("EDAT");

  return;
}

unsigned long int EDAT_Metrics::timerStart(std::string event_name) {
  // if emplace finds that the map already has an entry with the key event_name
  // it will just do nothing, so this is safe
  Timings walltimes = Timings();
  unsigned long int timer_key = getTimerKey();

  std::lock_guard<std::mutex> lock(event_times_mutex);

  event_times.emplace(event_name, walltimes);

  event_times.at(event_name).num_events++;

  event_times.at(event_name).start_times.emplace(timer_key, std::chrono::steady_clock::now());

  return timer_key;
}

void EDAT_Metrics::timerStop(std::string event_name, unsigned long int timer_key) {
  // uses a unique ulong int generated by getTimerKey to distinguish timing
  // events with the same event_name
  std::chrono::steady_clock::time_point t_stop = std::chrono::steady_clock::now();

  std::lock_guard<std::mutex> lock(event_times_mutex);
  std::chrono::steady_clock::time_point t_start
    = event_times.at(event_name).start_times.at(timer_key);
  event_times.at(event_name).start_times.erase(timer_key);

  ns delta_time = t_stop - t_start;

  if (delta_time > event_times.at(event_name).max) event_times.at(event_name).max = delta_time;
  if (delta_time < event_times.at(event_name).min) event_times.at(event_name).min = delta_time;
  event_times.at(event_name).sum += delta_time;

  if (!event_name.compare("Task")) {
    double dbl_delta_time = std::chrono::duration_cast<std::chrono::duration<double>>(delta_time).count();
    int magnitude = (int) std::floor(std::log10(dbl_delta_time));
    if (magnitude < -7) magnitude = -7;
    if (magnitude > 2) magnitude = 2;
    task_time_bins[magnitude + 7]++;
  }

  return;
}

void EDAT_Metrics::threadReport(int myThreadId, ns active_time) {
  thread_active[myThreadId] += active_time;

  return;
}

unsigned long int EDAT_Metrics::getTimerKey(void) {
  // statically initialises a ulong int and increments on every call
  // thread-safe
  static std::mutex timer_key_mutex;
  static unsigned long int timer_key = 0;

  std::lock_guard<std::mutex> lock(timer_key_mutex);
  return timer_key++;
}

void EDAT_Metrics::process(void) {
  // at the moment this general sounding member function just finishes
  // calculating the average
  std::map<std::string,Timings>::iterator et_iter;

  for (et_iter=event_times.begin(); et_iter!=event_times.end(); ++et_iter) {
    et_iter->second.avg = et_iter->second.sum / et_iter->second.num_events;
  }

  for (int i=0; i<num_threads; ++i) {
    thread_active_pc[i] = 100 * (double) thread_active[i].count() / event_times.at("EDAT").avg.count();
  }

  return;
}

void EDAT_Metrics::writeOut(void) {
  // we use the stringstream in order to try and prevent processes printing over
  // one another
  std::stringstream buffer;
  std::map<std::string,Timings>::iterator event;
  const int RANK = edatGetRank();

  std::chrono::duration<double> average;
  std::chrono::duration<double> min;
  std::chrono::duration<double> max;
  std::chrono::duration<double> sum;

  buffer.precision(4);
  buffer << std::scientific;
  buffer << "RANK [" << RANK << "] Walltimes (s)\n" << "EVENT\tCOUNT\tMEAN\tMIN\tMAX\tSUM\n";
  for (event=event_times.begin(); event!=event_times.end(); ++event) {
    sum = std::chrono::duration_cast<std::chrono::duration<double>>(event->second.sum);
    average = std::chrono::duration_cast<std::chrono::duration<double>>(event->second.avg);
    min = std::chrono::duration_cast<std::chrono::duration<double>>(event->second.min);
    max = std::chrono::duration_cast<std::chrono::duration<double>>(event->second.max);

    buffer << event->first << "\t" << event->second.num_events << "\t"
      << average.count() << "\t" << min.count() << "\t" << max.count()
      << "\t" << sum.count() << "\n";
  }

  buffer << "Task Timing [log10(seconds)]: \nMagnitude:  <=-7";
  for (int mag=-6; mag<2; mag++) buffer << " " << std::setw(5) << mag;
  buffer << "   >=2\n    Count:";
  for (int mag=-7; mag<3; mag++) buffer << " " << std::setw(5) << task_time_bins[mag+7];
  buffer << "\n";

  buffer << "Thread Activity: [% of EDAT time]\n";
  for (int i = 0; i<num_threads; ++i) buffer << "{" << i << ":" << std::fixed << std::setprecision(2) << thread_active_pc[i] << "%} ";

  // send buffer to stdout
  std::cout << buffer.str() << std::endl;

  return;
}

void EDAT_Metrics::finalise(void) {
  // process, report results, and delete the metrics::METRICS object
  timerStop("EDAT", edat_timer_key);
  this->process();
  this->writeOut();

  delete this;

  return;
}
